#!/usr/bin/env perl

use warnings;
use strict;

use  5.010_001;

use Getopt::Long;
use Pod::Usage;
use List::Util qw(sum max);
use Log::Log4perl;
use FindBin qw($RealBin);
use lib "$RealBin/../lib/";

use Cwd;
use File::Basename;
use File::Path qw(make_path remove_tree);
use File::Copy;
use File::Spec;
use File::Which;

use Verbose;
use Verbose::ProgressBar;

use Fastq::Parser 0.09;
use Fastq::Seq 0.13.3;

use Fasta::Parser 0.09;
use Fasta::Seq 0.9.0;

use Sam::Parser 0.11;
use Sam::Alignment 0.10 ':flags';
use Sam::Seq 0.16;

use Shrimp 0.08;

use threads;
use Thread::Queue;
use Time::HiRes qw(usleep);

use Data::Dumper;
$Data::Dumper::Sortkeys = 1;

use version 0.77; our $VERSION = qv("2.14.0");

my $RealLib = "$RealBin/../lib/";
my $RealPerl = "$^X -I${RealLib} $RealBin";

=head1 NAME

proovread

=cut

=head1 DESCRIPTION

Correct single molecule sequencing reads by iterative mapping of high
 throughput sequencing reads.

=head1 CHANGELOG

See git log.

=cut


##------------------------------------------------------------------------##

my $no_fatal;

# verbose
my $V = Verbose->new(
	format => "  {MESSAGE}\n",
	line_width => 80,
);

# verbose
my $VS = Verbose->new(
	format => "[{TIME_FULL}] {MESSAGE}\n",
	line_width => 80,
);

# verbose bash style
my $VB = Verbose->new(
	line_delim => "\\\n",
	line_width => 80,
	format => "{MESSAGE}\n",
);


$VS->verbose(sprintf("Running proovread-%vd under Perl %vd", $VERSION, $^V));

##------------------------------------------------------------------------##
## Config

# load core defaults
$VS->verbose("Reading core config");
my $cfg_core_file = "$RealBin/../proovread.cfg";
my %cfg = do $cfg_core_file;
$V->exit("An error ocuured while processing the config file: $@") if $@; # capture do errors on cfg


# load user defaults and overwrite core
my $cfg;
for(my $i=0; $i<@ARGV; $i++){
	if($ARGV[$i] =~ /--create-cfg$/){
		my $cfg_custom_file = $i < $#ARGV ? $ARGV[$i+1] : basename($cfg_core_file);
		$VS->verbose("Creating custom config file `$cfg_custom_file`");
		copy_custom_cfg($cfg_core_file, $cfg_custom_file);
		exit(0);
	}
	if($ARGV[$i] =~ /-c$|--cfg$/){
		$cfg = $ARGV[$i+1];
		last;
	}
}


if($cfg){
	unless(-e $cfg){
		$VS->exit("Cannot find config file `$cfg`");
	}
	$VS->verbose("Reading custom config `$cfg`");
	%cfg = (%cfg, do "$cfg");
	$V->exit("An error ocuured while processing the config file: $@") if $@; # capture do errors on cfg
}


##----------------------------------------------------------------------------##
## Options

$VS->verbose("Reading command line options");

# load cmd options and overwrite defaults
my %opt;

=head1 OPTIONS

=cut

=over

=item -l, --long-reads=<FASTA/FASTQ>

PacBio subreads or other erroneous sequences to be corrected.

=cut

$opt{'l|long-reads=s@'} = \(my $opt_lr_file = cfg('long-reads') || []);

=item [-u, --unitigs=<FASTA/FASTQ>]

High confidence unitigs. Can be specified multiple times.

=cut

$opt{'u|unitigs=s@'} = \(my $opt_utg_file = cfg('unitigs') || []);

=item -s, --short-reads=<FASTA/FASTQ>

High confidence short reads. Specify mulitple times for multiple libs, need to
have same format (FASTA/FASTQ and offset 33,64)

  -s lib1.fq -s lib2.fq # use reads from two libs

=cut

$opt{'s|short-reads=s@'} = \(my $opt_sr_file = cfg('short-reads') || []);

=item [--sam/--bam=<SAM/BAM>]

External SAM or sorted BAM file instead of --short-reads.

=cut

$opt{'sam=s'} = \(my $opt_sam_file = cfg('sam'));
$opt{'bam=s'} = \(my $opt_bam_file = cfg('bam'));

=item [-p, --prefix=<STRING>] [proovread]

Prefix to output files.

=cut

$opt{'p|prefix=s'} = \(my $opt_prefix = cfg('prefix'));

=item [--overwrite]

Overwrite output folder if it already exists.

=cut

$opt{'overwrite'} = \(my $opt_overwrite = cfg('overwrite'));

=item [-t, --threads] [4]

Number of threads to use for mapping and consensus.

=cut

$opt{'t|threads=i'} = \(my $opt_threads = cfg('threads'));

=item [--coverage=<INT>] [50]

Estimated short read coverage, 50X recommended.

=cut

$opt{'coverage=s'} = \(my $opt_cov = cfg('coverage'));

=item [-m, --mode] [auto]

Running mode of the pipeline, see README for details.

=cut

$opt{'m|mode=s'} = \(my $opt_mode= cfg('mode'));

=item [--create-cfg=<CFGFILENAME>] [<CWD>/proovread_cfg.pm]

Create a custom config file with advanced options. Does not run the
pipeline. For details, see config header section and README.

=item [-c, --cfg]

Use custom config file.

=cut

$opt{'c|cfg=s'} = \$cfg;

=item [--lr-qv-offset/--sr-qv-offset=<INT>] [auto]

Long/short read quality offset, required if auto-detect fails.

=cut

$opt{'lr-qv-offset=i'} = \(my $opt_lr_qv_offset = cfg('lr-qv-offset'));

$opt{'sr-qv-offset=i'} = \(my $opt_sr_qv_offset = cfg('sr-qv-offset'));

=item [--ignore-sr-length]

Don't stop if short reads are longer than 700bp.

=cut

$opt{'ignore-sr-length'} = \(my $opt_ignore_sr_length = cfg('ignore-sr-length'));

=item [--keep-temporary-files] [OFF]

Keep temporary files of each task (BAMs, masked FASTQs, etc.)

=cut

$opt{'keep-temporary-files+'} = \(my $opt_keep = cfg('keep-temporary-files'));

=item [--sample-run]

Run the sample data set to test installation.

=cut

$opt{'sample-run:s'} = \(my $opt_sample);

=item [--haplo-coverage] [OFF]

Adjust coverage for reads with low-coverage haplotype.

=cut

$opt{'haplo-coverage!'} = \(my $opt_haplo_coverage);

=item [--no-sampling]

Deactivate sampling, regardless of config settings.

=cut

$opt{'sampling!'} = \(my $opt_sampling = 1);

=item [-h, --help]

=item [-V, --version]

=item [--debug]

=cut

$opt{'h|help'} = \(my $opt_help);

$opt{'debug!'} = \(my $opt_debug = cfg('debug') );

$opt{'V|version'} = \(my $opt_version);

=back

=cut

## DEPRECATED
##$opt{'ram-sam'} = \(my $opt_ram_sam = cfg('ram-sam'));

##------------------------------------------------------------------------##


# parse options, test files
GetOptions(%opt) or pod2usage(1);
$opt_help && pod2usage(1);
if($opt_version){
    print "proovread-", $VERSION,"\n";
    exit(0);
}

if(defined $opt_sample){
    if($opt_sample =~ /^ec/i){
        $opt_lr_file = ["$RealBin/../sample/Ec-pb.fq"];
        $opt_sr_file = ["$RealBin/../sample/Ec-il-sim50X_1.fq"];
        $opt_sr_qv_offset = 64;
        if($opt_sample =~ /dazz/i){
            $opt_utg_file = ["$RealBin/../sample/Ec-utg-rand.fa"];
            $opt_prefix = 'pr-Ec-dazz' unless $opt_prefix;
            $opt_mode = 'sr+dazz-utg-noccs';
        }elsif($opt_sample =~ /uni|utg/i){
            $opt_utg_file = ["$RealBin/../sample/Ec-utg-rand.fa"];
            $opt_prefix = 'pr-Ec-utg' unless $opt_prefix;
        }else{
            $opt_prefix = 'pr-Ec' unless $opt_prefix;
        }
    }else{
        if($opt_sample =~ /dazz/i){
            $opt_lr_file = ["$RealBin/../sample/F.antasticus_long_error.fq"]; #
            $opt_sr_file = ["$RealBin/../sample/F.antasticus_short.fq"]; #
            $opt_utg_file = ["$RealBin/../sample/F.antasticus_utg.fa"]; #
            $opt_sr_qv_offset = 33;
            $opt_prefix = 'pr-Fa-utg' unless $opt_prefix;
            $opt_mode = 'sr+dazz-utg-noccs';
        }else {
            $opt_lr_file = ["$RealBin/../sample/F.antasticus_long_error.fq"]; #
            $opt_sr_file = ["$RealBin/../sample/F.antasticus_short.fq"]; #
            $opt_sr_qv_offset = 33;
            $opt_prefix = 'pr-Fa' unless $opt_prefix;
        }
    }
}

@$opt_lr_file || pod2usage("--long-read file required");
@$opt_sr_file || @$opt_utg_file || $opt_sam_file || $opt_bam_file ||
  pod2usage("Either --short-reads, --unitigs or --sam/--bam  required");
$opt_sam_file && ! -f $opt_sam_file && pod2usage("Cannot find SAM file `$opt_sam_file`");
$opt_bam_file && ! -f $opt_bam_file && pod2usage("Cannot find BAM file `$opt_bam_file`");


##------------------------------------------------------------------------##

=head1 PRE

=cut

=head2 create folder structure

=cut

$opt_prefix = 'proovread' unless $opt_prefix;
$VS->exit("Bad chars in prefix: $opt_prefix") if $opt_prefix =~ '^-';
$opt_prefix =~ s/\/$//; # remove trailing /

# create tmp folders
if(-e $opt_prefix){
	if(-d $opt_prefix){
		if($opt_overwrite){
			remove_tree($opt_prefix);
		}else{
			$VS->exit("Output directory already exists and is not empty")
			unless is_empty_dir($opt_prefix);
		}
	}else{
		$VS->exit("Output directory already exists, yet is no directory")
	}
}
make_path($opt_prefix);


# full path prefix support
my $prefix_path;
($opt_prefix, $prefix_path) = fileparse($opt_prefix);
my $odir = getcwd;

if ($prefix_path){
    chdir($prefix_path) || $VS->exit("$!: $prefix_path");
}

##------------------------------------------------------------------------##

=head2 log parameter

=cut

# 'cause I'm lazy


my $opt_param_log = task_file_name(task => '', suffix => ".parameter.log");
open(PARAM, '>', $opt_param_log) or $V->exit("$!: `$opt_param_log`");

$VS->verbose("Logging parameter to `$opt_param_log`");

my $cfg_string = Dumper(\%cfg);
$cfg_string =~ s/^.*\n//;
$cfg_string =~ s/\n.*$//;
print PARAM "Custom config parameter\n",$cfg_string;

my $cmd_string = Dumper(\%opt);
$cmd_string =~ s/^.*\n//;
$cmd_string =~ s/\n.*$//;
print PARAM "Command line parameter\n",$cmd_string;

close PARAM;

##------------------------------------------------------------------------##

my @sr_length;
my @sr_length_dev;
my @sr_count;
my $sr_count_total;
my $sr_qv_offset_total;
my @sr_matched;
my @sr_bps;

my $min_sr_length;
my $max_sr_dev;

if(@$opt_sr_file){
	$VS->verbose("Checking short read files");

	# short read files
	foreach(@$opt_sr_file){
		-e $_ || $VS->exit("Cannot find short read file `$_`");

		$V->verbose("\n".basename($_));

		# test if short reads are FASTQ/FASTA
		my $fp;
		my $sr_length;
		my $sr_length_dev = '0';
		my $sr_qv_offset;
		my $sr_count;

		# FASTQ
		if($fp = Fastq::Parser->new(file => $_)->check_format){
			$V->exit("Cannot handle gzipped files\n") if $fp->is_fh('GZIP');

			# format
			$V->verbose("Detected FASTQ format");

			# length
			($sr_length, $sr_length_dev) = $fp->guess_seq_length;
			$V->verbose(sprintf("Estimated short read length: %d +-%d", $sr_length, $sr_length_dev ));
			if(!$opt_ignore_sr_length && $sr_length > 1000){
				$V->exit(
					"Estimated short reads length > 1000\n"
					."Are you sure you specified the correct data? "
					."To run the pipeline on this data, which by design is not really suited, "
					."you need to specify --ignore-sr-length"
				);
			}

			# offset
			unless (defined $opt_sr_qv_offset){ # manual overwrite from config
				$sr_qv_offset = $fp->guess_phred_offset;
				$V->exit(
					"Estimating short read quality offset failed.\n"
					."See 'sr-qv-offset' in the advanced section for manual overwrite"
				) unless defined $sr_qv_offset;
				$V->verbose(sprintf("Etimated short read quality offset: %d", $sr_qv_offset));

				if(defined($sr_qv_offset_total)){
					$sr_qv_offset_total == $sr_qv_offset || $VB->exit('Different formats/quality offsets in short read files not allowed');
				}else{
					$sr_qv_offset_total = $sr_qv_offset;
				}
			}

			# count
			$sr_count = $fp->guess_seq_count();
			$V->verbose(sprintf("Estimating approximate number of short reads: %s", Verbose->Humanize($sr_count)));


		# FASTA
		}elsif($fp = Fasta::Parser->new(file=> $_)->check_format){
			# format
			$V->verbose("Detected FASTA format");

			# length
			($sr_length, $sr_length_dev) = $fp->guess_seq_length;
			$V->verbose(sprintf("Estimating short read length: %d +-%d", $sr_length, $sr_length_dev));
			if(!$opt_ignore_sr_length && $sr_length > 1000){
				$V->exit(
					"Estimated short reads length > 1000\n"
					."Are you sure you specified the correct data? "
					."To run the pipeline on this data, which by design is not really suited, "
					."you need to specify --ignore-sr-length"
				);
			}

			if(defined($sr_qv_offset_total)){
				$sr_qv_offset_total == 0 || $VB->exit('Different formats/quality offsets in short read files not allowed');
			}else{
				$sr_qv_offset_total = 0;
			}

			# count
			$sr_count = $fp->guess_seq_count();
			$V->verbose(sprintf("Estimating approximate number of short reads: %s", Verbose->Humanize($sr_count)));


		}else{
			$V->exit("Short read file $_ neither FASTQ nor FASTA format");
		}

		# push
		push @sr_length, $sr_length;
		push @sr_length_dev, $sr_length_dev;
		push @sr_count, $sr_count;
		push @sr_bps, ($sr_count * $sr_length);
		$sr_count_total+= $sr_count;
	}

	$sr_qv_offset_total = $opt_sr_qv_offset unless defined $sr_qv_offset_total;

	if(@$opt_sr_file){
		$min_sr_length = (sort{$a<=>$b}@sr_length)[0];
		$max_sr_dev = (sort{$b<=>$a}@sr_length_dev)[0];
		$min_sr_length+=$max_sr_dev;
	}
}


my @or_length;
my @or_length_dev;
my @or_count;
my $or_count_total;
my @or_matched;
my @or_bps;

my $min_or_length;
my $max_or_dev;
my $first_chunk = 1;

if($opt_utg_file && @$opt_utg_file){
	$VS->nline;
	$VS->verbose("Checking alternative read files");

	# short read files
	foreach my $utg_file (@$opt_utg_file){
		-e $utg_file || $VS->exit("Cannot find alternative read file `$utg_file`");

		$V->verbose("\n".basename($utg_file));

                $utg_file =~ /\.fasta$/ || $VS->exit("Unitig file needs to be FASTA and have '.fasta' suffix\n");

		# test if short reads are FASTQ/FASTA
		my $fp;
		my $or_length;
		my $or_length_dev = '0';
		my $or_qv_offset;
		my $or_count;

                if($fp = Fasta::Parser->new(file=> $utg_file)->check_format){
			# format
			$V->verbose("Detected FASTA format");

			# length
			($or_length, $or_length_dev) = $fp->guess_seq_length;
			$V->verbose(sprintf("Estimating fragment length: %d +-%d", $or_length, $or_length_dev));

                        # dont really care about length
			# dont care about offset

			# count
			$or_count = $fp->guess_seq_count();
			$V->verbose(sprintf("Estimating approximate number of fragments: %s", Verbose->Humanize($or_count)));

                        # guess length of unitig IDs
                        # for ( $fp->sample_seqs ){ # samtools has limit of 256 for ids
                        #     $V->exit("Unitig IDs too long (>256)\n>".($_->id)."\n") if length($_->id) > 256;
                        # }

                        # take the time and do the real thing
                        open(UTG, "$utg_file") or $V->exit("$!");
                        while (<UTG>) {
                            $V->exit("Unitig ID too long (>256)\n".$utg_file) if /^>\S{256}/;
                        }
                        close UTG;

		}else{
			$V->exit("Alternative read file needs to be in FASTA format. You can use `proovread/bin/SeqFilter --fasta --line-width 80 --out utg.fasta utg.fq` to convert FASTQ");
		}

		# push
		push @or_length, $or_length;
		push @or_length_dev, $or_length_dev;
		push @or_count, $or_count;
		push @or_bps, ($or_count * $or_length);
		$or_count_total+= $or_count;
	}

	if(@$opt_utg_file){
		$min_or_length = (sort{$a<=>$b}@or_length)[0];
		$max_or_dev = (sort{$b<=>$a}@or_length_dev)[0];
		$min_or_length+=$max_or_dev;
	}
}




=head2 mode

=cut

# globals
my $PG_line = '@PG ID:unknown';

# mode
my @TASKS;
my $TC = -1;
my $TASK; # current task

if($opt_bam_file){
    $opt_mode = 'bam';
}elsif($opt_sam_file){
    $opt_mode = 'sam';
}else{
    if(! $opt_mode or $opt_mode eq "auto"){
        if(! $min_sr_length){
            if($opt_utg_file && @$opt_utg_file){
                $opt_mode ="utg";
            }
        }elsif($min_sr_length > 150){
            $opt_mode = 'mr';
        }else{
            $opt_mode = 'sr';
        }

    }

    if($opt_utg_file && @$opt_utg_file){
        unless($opt_mode =~ /utg/){
            $opt_mode.="+utg";
        }
    }
}

$V->exit("unknown mode $opt_mode") unless exists $cfg{'mode-tasks'}{$opt_mode};
@TASKS = @{$cfg{'mode-tasks'}{$opt_mode}};

# DIRTY FIX: mode unitigs w/o sr reads
$min_sr_length = 200 unless $min_sr_length;

#unshift @TASKS, 0; # tasks are counted from 1, 0 just fills the array index :)

# binaries
$VS->nline;
$VS->verbose('Checking required binaries');
$VS->nline;

check_binary(cfg('samtools-path')."samtools", ["--version", "1.1"]);
check_binary(cfg('shrimp-path')."gmapper-ls") if (grep{/shrimp/}@TASKS);
check_binary(cfg('bwa-path')."bwa-proovread") if (grep{/bwa/}@TASKS);
check_binary(cfg('blasr-path')."blasr") if (grep{/blasr/}@TASKS);
check_binary(cfg('daligner-path')."daligner") if (grep{/dazzler/}@TASKS);
check_binary(cfg('dazz-db-path')."DBshow") if (grep{/dazzler/}@TASKS);
check_binary(cfg('blast-path')."blastn", ["-version", "2.2.24" ]) if (defined cfg('siamaera'));

$VS->nline;

$VS->verbose('Running mode: '.$opt_mode);

=head2 create temporary folders

=cut

my @tmp_dirs = (map{$opt_prefix."/".$_}@TASKS);
make_path(@tmp_dirs);



##------------------------------------------------------------------------##

=head1 MAIN

=cut


my @LR_IDS;
my @LR_IDS_IGNORED;
my $lr_chunk_offsets;
my @lr_count;
my @lr_length;
my @lr_bps;
my $sr_bps_total;
my $lr_bps_total;
my $estimated_coverage;
my @masked_fracs = ();

while($TC < $#TASKS){
	$TC++;
        my $task = $TASK = $TASKS[$TC];

	if($TASK eq 'read-long'){

		# long read files
		foreach(@$opt_lr_file){
			-e $_ || $VS->exit("Cannot find long read file `$_`");
		}

		$lr_chunk_offsets = read_long() if @$opt_lr_file; # 'external-sam does not require LR

        }elsif($TASK eq 'read-sam'){
		read_sam();
		create_sorted_bam();
		$lr_chunk_offsets = correct_sr_mt($lr_chunk_offsets);

        }elsif($TASK eq 'read-bam'){
          	my $bam_file = task_file_name(".bam");
                $opt_bam_file = File::Spec->rel2abs($opt_bam_file);
          	qx(ln -s  $opt_bam_file $bam_file);
                $? && $VS->exit("Failed to link $opt_bam_file");

                my $sam_index_cmd = cfg('samtools-path')."samtools index $bam_file";
                $VB->hline();
                $VB->verbose($sam_index_cmd);
                $VB->hline();
                qx($sam_index_cmd);
                $V->exit("samtools index failed: $?\n") if $?;

		$lr_chunk_offsets = correct_sr_mt($lr_chunk_offsets);

        }elsif($TASK =~ m/^shrimp-.*\d$/){

		run_shrimp(
			sr_files => $opt_sr_file,
			sr_sampling => cov2seqchunker($opt_cov, cfg('sr-coverage', $TASK)),
			shrimp => {
				cfg($TASK), # basic shrimp params from cfg
				'verbose' => 1,
				'log' => task_file_name(suffix => "_shrimp.log"),
				'ref' => task_file_name(".masked.fa", task => $TASKS[$TC-1] ),
				#'--al' => task_file_name(suffix => "_sr.fq"),
				'--threads' => $opt_threads,
				'--qv-offset' => $sr_qv_offset_total,
			}
		);

	        create_sorted_bam();

                my $masked_frac;
		($lr_chunk_offsets, $masked_frac) = correct_sr_mt($lr_chunk_offsets);
                mask_shortcut_frac($masked_frac, \@masked_fracs);

	}elsif($TASK eq 'shrimp-finish'){
		my $sr_finish_files;

		$sr_finish_files = $opt_sr_file;

		# create a unmasked reference for finish run
		seq_filter(
                           '--in' => task_file_name('.fq', task => $TASKS[$TC-1] ),
                           '--out' => task_file_name('.unmasked.fa', task => $TASKS[$TC-1] ),
                           '--fasta' => '',
                           '--quiet' => '',
                           '--phred-offset' => 33,
		);

		run_shrimp(
			sr_files => $sr_finish_files,
			shrimp => {
				cfg($TASK), # basic shrimp params from cfg
				'verbose' => 1,
				'ref' => task_file_name('.unmasked.fa', task => $TASKS[$TC-1] ),
				'--threads' => $opt_threads,
				'--qv-offset' => $sr_qv_offset_total,
			}
		);

		create_sorted_bam();

		$lr_chunk_offsets = correct_sr_mt($lr_chunk_offsets);

	}elsif($TASK eq 'blasr-utg'){

                run_blasr(
			or_files => $opt_utg_file,
                        blasr => {
				cfg($TASK), # basic shrimp params from cfg
				'log' => task_file_name(suffix => "_blasr.log"),
 				'ref' => $TC > 0
                                  ? task_file_name('.masked.fa', task => $TASKS[$TC-1] )
                                  : task_file_name('.fa', task => $TASKS[$TC-1] ),
				'-nproc' => $opt_threads,
			}
		);

		create_sorted_bam();

		$lr_chunk_offsets = correct_sr_mt($lr_chunk_offsets);


	}elsif($TASK eq 'dazzler-utg'){

            run_dazzler(or_files => $opt_utg_file);

            create_sorted_bam();

            $lr_chunk_offsets = correct_sr_mt($lr_chunk_offsets);


	}elsif($TASK eq 'bwa-utg'){

                run_bwa(
			or_files => $opt_utg_file,
                        bwa => {
				cfg($TASK), # basic shrimp params from cfg
				'log' => task_file_name(suffix => "_bwa.log"),
				'ref' => $TC < 2
                                  ? task_file_name('.masked.fa', task => $TASKS[$TC-1] )
                                  : task_file_name('.fa', task => $TASKS[$TC-1] ),
				'-t' => $opt_threads,
			}
		);

		create_sorted_bam();

		$lr_chunk_offsets = correct_sr_mt($lr_chunk_offsets);

	}elsif($TASK =~ m/^bwa-/){

		# cerate a unmasked reference for finish run
		my $ref_file;
		if($TASK =~ m/-finish$/){
			$ref_file = task_file_name('.unmasked.fa', task => $TASKS[$TC-1] );

                        seq_filter(
                                   '--in' => task_file_name('.fq', task => $TASKS[$TC-1] ),
                                   '--out' => task_file_name('.unmasked.fa', task => $TASKS[$TC-1] ),
                                   '--fasta' => '',
                                   '--quiet' => '',
                                   '--phred-offset' => 33,
                                  );
		}else{
			$ref_file = task_file_name('.masked.fa', task => $TASKS[$TC-1] )
		}

		run_bwa(
			or_files => $opt_sr_file,
			sr_sampling => cov2seqchunker($opt_cov, cfg('sr-coverage', $TASK)),
			bwa => {
				cfg($TASK), # basic task params from cfg
				'ref' => $ref_file,
                                'log' => task_file_name(suffix => "_bwa.log"),
				'-t' => $opt_threads,
			}
		);


                create_sorted_bam();

                my $masked_frac;
		($lr_chunk_offsets, $masked_frac) = correct_sr_mt($lr_chunk_offsets);
                mask_shortcut_frac($masked_frac, \@masked_fracs);

        }elsif($TASK =~ m/^ccs-\d+/){
            my $fqi = task_file_name('.fq', task => $TASKS[$TC-1]);
            my $fqo = task_file_name('.fq', task => $TASKS[$TC]);
            my $fmo = task_file_name('.masked.fa', task => $TASKS[$TC]);

            my @ccs_mask = split(",", cfg('hcr-mask', $TASK));
            $ccs_mask[2] = int(($ccs_mask[2] * $min_sr_length  / 100 ) +.5);
            $ccs_mask[3] = int(($ccs_mask[3] * $min_sr_length  / 100 ) +.5);
            my $ccs_mask = join(",", @ccs_mask );

            my $cmd = "$RealPerl/ccseq ".($opt_debug ? "--debug " : "").(cfg('bwa-path') ? "--bwa-path ".cfg('bwa-path') : "")." --threads $opt_threads --pre $opt_prefix/$TASK <$fqi | tee $fqo | "
              ."$RealPerl/SeqFilter --line-width 80 --phred-offset 33 --phred-mask $ccs_mask --fasta --out $fmo --base-content N --tsv - --quiet";

            $VB->hline;
            $VB->verbose($cmd);
            my $re = qx($cmd);
            my ($bpt, $bpN) = (split(/\s/, $re))[1,6];
            $VB->hline;

            $V->exit("ccseq failed: $?\n") if $?;
            # $VB->nline;
            # $VS->verbose(sprintf "Masked: %0.1f%%", $bpN/$bpt*100);
            # $VB->nline;

            $lr_chunk_offsets = chunk_index($fqo);

	}else{
		$VB->exit("unknown task: ".$TASK);
	}
}



# create final output
my $opt_fq_raw = task_file_name(task => '', suffix => ".untrimmed.fq");
my $opt_fa_fil = task_file_name(task => '', suffix => ".trimmed.fa");
my $opt_fq_fil = task_file_name(task => '', suffix => ".trimmed.fq");

$VS->verbose("Creating raw output sequences");

copy(task_file_name(".fq", task=>$TASKS[$TC]), $opt_fq_raw);

my $opt_chim_raw = task_file_name(task => $TASKS[$TC], suffix => ".chim.tsv");
my $opt_chim_fil = task_file_name(task => '', suffix => ".chim.tsv");

chim_filter('--in' => $opt_chim_raw, '--out' => $opt_chim_fil);


if(cfg('seq-filter')){
	$V->nline;


	if(cfg('siamaera')){
		$VS->verbose("Quality trimming and siamaera filtering raw output");
		seq_and_siamaera_filter([
			cfg('seq-filter'),
			'--substr' => $opt_chim_fil,
			'--in' => $opt_fq_raw,
                        '--phred-offset' => 33,
		],[
			cfg('siamaera'),
			'>' => $opt_fq_fil
		]);
	}else{
		$VS->verbose("Quality trimming raw output");
		seq_filter(
			cfg('seq-filter'),
			'--substr' => $opt_chim_fil,
			'--in' => $opt_fq_raw,
			'--out' => $opt_fq_fil,
                        '--phred-offset' => 33,
		);
	}
}


if(cfg('seq-filter') && -s $opt_fq_fil){ # no need to create FASTA from empty FASTQ
	$V->nline;
	$VS->verbose("Converting to FASTA file");
	seq_filter(
                   '--in' => $opt_fq_fil,
                   '--out' => $opt_fa_fil,
                   '--fasta' => '',
                   '--phred-offset' => 33,
	);
}


# lets see if we came this far
$no_fatal++;

# put in END to wait for memory to be cleaned


END{
        chdir($odir) if $odir;
	if ($no_fatal){
		unless ($opt_keep){
			$VS->verbose("Cleaning up");
			remove_tree(@tmp_dirs)
		};
		$V->verbose("Total time spent", format => "{TIME_FULL}] {MESSAGE} {TIME_ELAPSED}\n");
		$VS->verbose("Done");
	}
}




##------------------------------------------------------------------------##

=head1 METHODS

=cut



=head2 read_sam



=cut

sub read_sam{

	my %LR;

	# init input stream parser
	my $rsp = Sam::Parser->new(
		file => $opt_sam_file
	);

	$VS->verbose("Reading SAM file `$opt_sam_file`");

	# read sam header
	while(my %h = $rsp->next_header_line('SQ|PG')){
            push @LR_IDS, $h{'SN'};
        }

	@LR_IDS = sort byfile keys %LR;

        my $bam_file = task_file_name("_tmp.bam");
	$VS->verbose("Converting to BAM file `$bam_file`");

        my $bam_cmd = cfg('samtools-path')."samtools view -@ $opt_threads -bS $opt_sam_file >".$bam_file;

        $VB->hline();
        $VB->verbose($bam_cmd);
        $VB->hline();
        qx($bam_cmd);

        $V->exit("samtools failed: $?\n") if $?;

        return \%LR;
}



=head2 run_shrimp

Run and process shrimp

=cut

sub run_shrimp{
    my $p = {
             sr_files => [],
             sr_sampling => 0,
             shrimp => {},
             tmp_bam => task_file_name("_tmp.bam"),
             @_
            };

    $V->nline;
    $VS->verbose("Running task ".$TASK);

    # Index genome file first and save projection for multiple short read
    #  files
    $VS->verbose("Indexing Long reads");

    # init shrimp handler
    my $shrimp_ldx = Shrimp->new(
                                 %{$p->{shrimp}},
                                 bin => cfg('shrimp-path').'gmapper-ls',
                                 '--save' => task_file_name("_shrimp_idx"),
                                 'log' => task_file_name(suffix => "_shrimp_idx.log"),
                                );

    $VB->hline();
    $VB->verbose($shrimp_ldx->command());
    $VB->hline();

    # run shrimp
    $shrimp_ldx->run->finish;

    my $sr_files = "@{$p->{sr_files}}";

    $VS->verbose("Mapping short reads `$sr_files`");

    # init shrimp handler
    my $shrimp = Shrimp->new(
                             %{$p->{shrimp}},
                             bin => cfg('shrimp-path').'gmapper-ls',
                             'ref' => undef,
                             ($p->{sr_sampling}
                              ? (
                                 'reads' => '/dev/fd/0',
                                 'pre_command' => seq_chunker(
                                                              'NO_EXEC',
                                                              $sr_files,
                                                              %{cov2seqchunker($opt_cov, cfg('sr-coverage', $TASK))},
                                                             ) . ' | ',
                                )
                              : ('reads' => $sr_files)
                             ),
                             '--load' => task_file_name("_shrimp_idx"),
                             '-s' => undef, # cannot specify seeds when loading genome
                            );

    my $shrimp_log = task_file_name("_shrimp_sr.log");
    my $shrimp_cmd = $shrimp->command()." 2>$shrimp_log | ".cfg('samtools-path')."samtools view -@ $opt_threads -bS /dev/fd/0 >$p->{tmp_bam}" ;

    $VB->hline();
    $VB->verbose($shrimp_cmd);
    $VB->hline();
    qx($shrimp_cmd);

    $V->exit("shrimp failed: $?\n", do { local $/; local @ARGV = ("$shrimp_log") ; <> }) if $?;
}

=head2 run_blasr

Run and process blasr

=cut

sub run_blasr{
    my $p = {
             or_files => [],
             blasr => {},
             tmp_bam => task_file_name("_tmp.bam"),
             @_
            };

    $V->nline;
    $VS->verbose("Running task ".$TASK);

    my $or_files = "@{$p->{or_files}}";

    $VS->verbose("Mapping reads `$or_files`");

    my @blasr_opts;
    while (my ($k, $v) = each %{$p->{blasr}}) {
        push @blasr_opts, $k, $v if $k =~ /^-/;
    }

    my $blasr_cmd = cfg('blasr-path')."blasr $or_files $p->{blasr}{ref} @blasr_opts -sam 2>$p->{blasr}{log} | ".cfg('samtools-path')."samtools view -@ $opt_threads -bS /dev/fd/0 >$p->{tmp_bam}";

    $VB->hline();
    $VB->verbose($blasr_cmd);
    $VB->hline();
    qx($blasr_cmd);

    $V->exit("blasr failed: $?\n", do { local $/; local @ARGV = ("$p->{blasr}{log}") ; <> }) if $?;

}


=head2 run_dazzler

Run and process blasr

=cut

sub run_dazzler{
    my $p = {
             or_files => [],
             @_
            };

    $V->nline;
    $VS->verbose("Running task ".$TASK);

    my $dir = task_file_name(prefix => '');
    my @or_files = map{File::Spec->rel2abs($_)}@{$p->{or_files}};

    my $ref_tmp = $TC > 0
        ? File::Spec->rel2abs(task_file_name('.masked.fa', task => $TASKS[$TC-1] ))
        : File::Spec->rel2abs(task_file_name('.fa', task => $TASKS[$TC-1] ));

    chdir($dir) or $V->exit($!);
    my $rfa = $opt_prefix.".fasta";
    my $rdb = $opt_prefix;
    my $qdb = $opt_prefix."-utg";
    my $log = $opt_prefix."-dazz.log";
    my @qfa;
    my $c=0;
    foreach my $qf ( @or_files ) {
        my $qfa = $opt_prefix."-utg".($c++).".fasta";
        qx(ln -s $qf $qfa);
        push @qfa, $qfa;
    }

    qx(ln -s $ref_tmp $rfa);

    my $cmd;

    $VS->verbose("Creating DAMs");
    $cmd = cfg('dazz-db-path')."fasta2DAM $qdb.dam @qfa 2>$log";
    $VB->hline();
    $VB->verbose($cmd);
    $VB->hline();
    qx($cmd);
    $V->exit("fasta2DAM failed: $?\n", do { local $/; local @ARGV = ($log) ; <> }) if $?;

    # fix short sequence error in daligner - yuragal #16
    $VS->verbose("Filter DAMs");
    $cmd = cfg('dazz-db-path')."DBsplit -x100 $qdb";
    $VB->hline();
    $VB->verbose($cmd);
    $VB->hline();
    qx($cmd);
    $V->exit("DBsplit failed: $?\n", do { local $/; local @ARGV = ($log) ; <> }) if $?;

    $VS->verbose("Creating read database");
    $cmd = cfg('dazz-db-path')."fasta2DAM $rdb.dam $rfa 2>>$log";
    $VB->hline();
    $VB->verbose($cmd);
    $VB->hline();
    qx($cmd);
    $V->exit("fasta2DAM failed: $?\n", do { local $/; local @ARGV = ($log) ; <> }) if $?;


    $VS->verbose("Mapping unitigs");

    # opts
    # my $blasr_cmd = cfg('blasr-path')."blasr $or_files $p->{blasr}{ref} @blasr_opts -sam 2>$p->{blasr}{log} | ".cfg('samtools-path')."samtools view -@ $opt_threads -bS /dev/fd/0 >$p->{tmp_bam}";
    my $dazz = task_file_name("-dazz.sh");
    my $dap = cfg('daligner-path');
    my $hpc = $dap."HPCmapper $rdb.dam $qdb.dam 2>>$log";
    $cmd = qx($hpc);
    $cmd =~ s/(?=daligner|LAmerge|LAsort)/$dap/g;
    $cmd =~ s/-k20 -h50 -e.85/ -k15 -h35 -e.8/;
    $VB->hline();
    $VB->verbose($cmd);
    $VB->hline();
    qx($cmd);
    $V->exit("daligner failed: $?\n", do { local $/; local @ARGV = ($log) ; <> }) if $?;

    # crutial fix for merging las files - yuragal #16
    $VS->verbose("Combine .las files");
    $cmd = cfg('daligner-path')."LAcat $opt_prefix.$opt_prefix-utg > $opt_prefix.$opt_prefix-utg.las";
    $VB->hline();
    $VB->verbose($cmd);
    $VB->hline();
    qx($cmd);
    $V->exit("LAcat failed: $?\n", do { local $/; local @ARGV = ($log) ; <> }) if $?;

    $VS->verbose("Converting to/sorting BAM");
    $cmd = "($RealPerl/dazz2sam"
        . (cfg('dazz-db-path') ? " --dazz-db-path ".cfg('dazz-db-path') : "")
        . (cfg('daligner-path') ? " --daligner-path ".cfg('daligner-path') : "")
        ." --add-scores"
        ." --las $opt_prefix.$opt_prefix-utg.las"
        ." --ref $rdb.dam --qry $qdb.dam"
        ." | ".cfg('samtools-path')."samtools view -@ $opt_threads -bS /dev/fd/0 >${opt_prefix}_tmp.bam )2>>$log";
    $VB->hline();
    $VB->verbose($cmd);
    $VB->hline();
    qx($cmd);
    $V->exit("Converting to BAM failed: $?\n", do { local $/; local @ARGV = ($log) ; <> }) if $?;

    chdir("../..") or $V->exit($!);

}


=head2 run_bwa

Run and process bwa

=cut

sub run_bwa{
    my $p = {
        or_files => [],
             sr_sampling => 0,
             bwa => {},
             tmp_bam => task_file_name("_tmp.bam"),
             @_
            };

    $V->nline;
    $VS->verbose("Running task ".$TASK);

    # Index genome file first and save projection for multiple short read
    #  files
    $VS->verbose("Indexing Long reads");

    my $bwa_index_cmd = cfg('bwa-path')."bwa-proovread index $p->{bwa}{ref} $p->{bwa}{ref} 2>$p->{bwa}{log}";

    $VB->hline();
    $VB->verbose($bwa_index_cmd);
    $VB->hline();

    qx($bwa_index_cmd);
    $V->exit("bwa failed: $?\n", do { local $/; local @ARGV = ("$p->{bwa}{log}") ; <> }) if $?;

    my $pg_rsp;
    my $pg_step;

    ### foreach sr file read mappings
    my $or_files = "@{$p->{or_files}}";

    $VS->verbose("Mapping reads `$or_files`");

    my @bwa_opts;
    while (my ($k, $v) = each %{$p->{bwa}}) {
        push @bwa_opts, $k, $v if $k =~ /^-/;
    }

    my $pre_command = "cat $or_files | ";
    if ($p->{sr_sampling}) {
        $pre_command = seq_chunker(
                                   'NO_EXEC',
                                   $or_files,
                                   %{$p->{sr_sampling}},
                                  )
            . ' | ';
    }

    my ($bin_size, $bin_length);
    if ($TASK =~ /utg/) {
        $bin_size = cfg('utg-bin-size');
        $bin_length = $bin_size * cfg('utg-bin-coverage');
    } else {
        $bin_size = cfg('bin-size', $opt_mode);
        my $task_cov = cfg('sr-coverage', $TASK);
        my $bin_cov = ($opt_cov < $task_cov ? $opt_cov : $task_cov);
        $bin_length = $bin_size * $bin_cov;
    }

    my $bwa_cmd = $pre_command.cfg('bwa-path')."bwa-proovread mem -b $bin_size -l $bin_length @bwa_opts $p->{bwa}{ref} /dev/fd/0 2>$p->{bwa}{log} | ".cfg('samtools-path')."samtools view -@ $opt_threads -bS /dev/fd/0 >$p->{tmp_bam}" ;

    $VB->hline();
    $VB->verbose($bwa_cmd);
    $VB->hline();
    qx($bwa_cmd);

    $V->exit("bwa failed: $?\n", do { local $/; local @ARGV = ("$p->{bwa}{log}") ; <> }) if $?;

}



=head2 create_sorted_bam

=cut

sub create_sorted_bam{
    my $opt_bam = task_file_name("_tmp.bam");
    my $opt_bam_out = task_file_name("");

    $VS->nline;
    $VS->verbose("Sorting BAM `$opt_bam_out.bam`");

    # restrict threads to prevent mem overflow
    my $sam_sort_cmd = cfg('samtools-path')."samtools sort -m 2G -@ ".($opt_threads > 2 ? int(2 + ($opt_threads-2)/2) : $opt_threads)." -T ".$opt_bam_out."_tmp -o ".$opt_bam_out.".bam $opt_bam";
    $VB->hline();
    $VB->verbose($sam_sort_cmd);
    $VB->hline();
    qx($sam_sort_cmd);
    $V->exit("samtools sort failed: $?\n") if $?;

    $VS->nline;
    $VS->verbose("Indexing BAM `$opt_bam_out`");

    my $sam_index_cmd = cfg('samtools-path')."samtools index $opt_bam_out.bam";
    $VB->hline();
    $VB->verbose($sam_index_cmd);
    $VB->hline();
    qx($sam_index_cmd);
    $V->exit("samtools index failed: $?\n") if $?;

}





=head2 read_long

Read the pacbio long read file and create a new, indexed long read file,
 ordered the same way as the sorted sam files.

=cut

sub read_long{

	$VS->verbose("Preparing long reads");

	# read fasta/fastq, write and sort by id
	my %lr;

	my $lrpw;

        my $noccs;

	foreach(@$opt_lr_file){

		my $lrpr;
		$lrpr = Fasta::Parser->new(file => $_)->check_format();
		$lrpr = Fastq::Parser->new(file => $_)->check_format() unless $lrpr;
		$lrpr || $VS->exit("Unknown format in '--long-read' file `$_`");
		$lrpr eq 'Fastq::Parser' && $lrpr->is_fh('GZIP') && $VS->exit("Cannot handle gzipped files");

		my $lr_count = $lrpr->guess_seq_count();
		push @lr_count, $lr_count;
		my ($lr_length, $lr_dev) =  $lrpr->guess_seq_length;
		push @lr_length, $lr_length;
		push @lr_bps, ($lr_length * $lr_count);


                $lrpw = Fastq::Parser->new(
                                           file => task_file_name(".fq", task => $TASKS[$TC] ),
                                           mode => '+>'
                                          );

		if(ref $lrpr eq 'Fasta::Parser'){ # FASTA ref

			my $fi_file = task_file_name(suffix => ".ignored.tsv", task => '');
			my $stubby_count = 0;
			open(IGNORE, '>>', $fi_file) or $VS->exit($!." $fi_file");
			while(my $lr = $lrpr->next_seq){
                            	unless( my($id,$range) = $lr->id =~ m!^(m[^/]+/\d+)/(\d+_\d+)!){
                                    $noccs++;
                                }

                                if(length($lr->seq) < 2*$min_sr_length){
					$stubby_count++;
					printf IGNORE "%s\t%s\n", $lr->id, "stubby";
					next;
				}
				if(exists $lr{$lr->id}){
					$VS->exit('Non-unique long read id ('. $lr->id .') in '. $_);
				}

                                $lr->{seq} =~ tr/ATGCNatgcn/N/c;  # remove iupac chars

				$lr{$lr->id} = Fastq::Seq->new(
                                                               '@'.substr($lr->seq_head,1),
                                                               uc($lr->seq),
                                                               "+",
                                                               '$'x length($lr->seq)
                                                              );
                        }
			close IGNORE;
			$V->verbose("Skipped $stubby_count stubby reads with length <".2*$min_sr_length) if $stubby_count;

		}else{ # FASTQ ref
			if($opt_mode eq 'sam' or $opt_mode eq 'bam' ){
				my $po = $lrpr->guess_phred_offset || $opt_lr_qv_offset;
				$V->exit("Cannot guess phred offset from provided reference file, please specify --lr-qv-offset")
					unless $po;
				$V->exit("Only offset 33 and 64 are supported")
					unless $po;

				$lrpr->phred_offset($po);

				while(my $lr = $lrpr->next_seq){
                                    	unless( my($id,$range) = $lr->id =~ m!^(m[^/]+/\d+)/(\d+_\d+)!){
                                            $noccs++;
                                        }

                                        if(exists $lr{$lr->id}){
						$VS->exit('Non-unique long read id ('. $lr->id .') in '. $_);
					}
					# convert seq to lower case, allow HCRs in external-sam
					$lr->phred_transform if $po == 64;

                                        $lr->{seq} =~ tr/ATGCNatgcn/N/c;  # remove iupac chars

					$lr{$lr->id} = $lr;
                                }

			}else{

				my $fi_file = task_file_name(suffix => ".ignored.tsv", task => '');
				my $stubby_count = 0;
				open(IGNORE, '>>', $fi_file) or $VS->exit($!." $fi_file");
				while(my $lr = $lrpr->next_seq){
                                    	unless( my($id,$range) = $lr->id =~ m!^(m[^/]+/\d+)/(\d+_\d+)!){
                                            $noccs++;
                                        }

                                        if(length($lr->seq) < 2*$min_sr_length){
						$stubby_count++;
						printf IGNORE "%s\t%s\n", $lr->id, "stubby";
						next;
					}
					if(exists $lr{$lr->id}){
						$VS->exit('Non-unique long read id ('. $lr->id .') in '. $_);
					}

                                        $lr->seq(uc($lr->seq()));

                                        $lr->{seq} =~ tr/ATGCNatgcn/N/c;  # remove iupac chars

					$lr{$lr->id} = $lr;
				}
				close IGNORE;
				$V->verbose("Skipped $stubby_count stubby reads with length <".2*$min_sr_length) if $stubby_count;

			}
		}
	}




	# write sorted/indexed fq/fa lr file for mapping/sam2cns
	my @lr_idxs;
	my $lr_c = 0;
	@LR_IDS = sort byfile keys %lr;
	foreach(@LR_IDS){
		my $pos = $lrpw->append_seq($lr{$_}, 80);
		push @lr_idxs, $pos unless $lr_c % cfg('chunk-size');
		$lr_c++;
	}

        seq_filter(
                   '--in' => $lrpw->{file},
                   '--out' => task_file_name('.masked.fa', task => $TASKS[$TC] ),
                   '--fasta' => '',
                   '--lower-case' => '',
                   '--phred-offset' => 33,
                   '--line-width' => 80,
                  );

        if($opt_mode !~ /noccs/ &&$noccs && grep{$_ =~ /ccs/}@TASKS){
            $opt_mode =~ s/^([^-]+)/$1-noccs/;
            $VS->verbose("Read IDs don't look like proper PacBio subread IDs.\nFalling back to running mode: $opt_mode");
            $V->exit("unknown mode $opt_mode") unless exists $cfg{'mode-tasks'}{$opt_mode};
            @TASKS = @{$cfg{'mode-tasks'}{$opt_mode}};
        }

        return \@lr_idxs;
}



=head2 correct_sr_mt

=cut

sub correct_sr_mt{
	my ($lr_chunk_offsets) = @_;

	$V->nline;
	$VS->verbose("Correcting Sequences (".@$lr_chunk_offsets." batches)");

        my $max_cov;
        my $bin_size;
        if($TASK =~ /utg/){
            $max_cov = 1;
            $bin_size = cfg('utg-bin-size');
        }else{
            my $task_cov = cfg('sr-coverage', $TASK);
            $max_cov = ($opt_cov < $task_cov ? $opt_cov : $task_cov) * cfg('coverage-scale-factor');
            $bin_size = cfg('bin-size', $opt_mode);
        }


	# sam2cns
	my %bam2cns_default = (
                '--bam' => task_file_name(".bam"),
		'--max-ref-seqs' => cfg('chunk-size'),
		'--coverage' => $max_cov,
                '--bin-size' => $bin_size,
		'--append' => 1,
		'--cfg'	=> $cfg || undef,
		'--mask-weak-reads' => cfg('mask-weak-reads', $TASK),
		'--ignore-weak-reads' => cfg('ignore-weak-reads', $TASK),
                '--max-ins-length' => cfg('max-ins-length', $TASK),

                $opt_debug ? ("--debug" => '') : (),
                $opt_haplo_coverage ? ('--haplo-coverage' => '') : (),

                defined(cfg('rep-coverage', $TASK)) ? ('--rep-coverage' => cfg('rep-coverage', $TASK)) : (),
                defined(cfg('min-ncscore', $TASK)) ? ('--min-ncscore' => cfg('min-ncscore', $TASK)) : (),

		cfg('detect-chimera', $TASK) ? ('--detect-chimera' => '') : (),
		cfg('mcr-ignore', $TASK) ? ('--ignore-hcr' => '') : (),

                ($TASK =~ /blasr/) # blasr has descending, negative scores!!
                    ? ('--invert-scores' => '') : (),

                @$opt_lr_file
			? ('--ref' => task_file_name(".fq", task => $TASKS[$TC-1] )) : (),

                ($TASK =~ /-finish/) # calculate hcrs on first iter for second iter
			? (
                           '--max-ins-length' => 0,
                           '--no-use-ref-qual' => '',
                           '--ignore-hcr' => '',
			  )
			: (),

                ($TASK =~ /utg/) # calculate hcrs on first iter for second iter
			? (
                           '--utg-mode' => '',
                           '--qual-weighted' => '',
                           '--fallback-phred' => 30, # use phred 30 for high confidence utgs
                          ) : (),

		($TASK eq 'read-sam') # calculate hcrs on first iter for second iter
			? (@$opt_lr_file ? () : ('--ignore-hcr' => 1)) : (),

	);

	my $bam2cns_cmds = '';

	# generate xargs statements foreach chunk
	for(my $ci=0; $ci<@$lr_chunk_offsets; $ci++){
		my %bam2cns_config = (
			%bam2cns_default,
			'--prefix'		=> task_file_name(".".$ci),
			'--ref-offset' => $lr_chunk_offsets->[$ci],
			'--qv-offset' => 33,
		);

		# params
		$bam2cns_cmds.= param_join(\%bam2cns_config)."\n";
	}

	# write cmd file

	my $cfg_file = task_file_name(".cmds");
	open(CFG, '>', $cfg_file) or $VS->exit($!);
	print CFG $bam2cns_cmds;
	close CFG;

	# xarg cmds, capture stderr;
        my $cns_bin = "bam2cns";

	my $xgr;
	open($xgr, "(cat $cfg_file | xargs -P $opt_threads -L 1 -t $RealPerl/$cns_bin) 2>&1 |")
		or $VS->exit($!);

	$VB->hline();
	#
	my $bc;
	my $bs = "Batch %d/".@$lr_chunk_offsets;
	while(<$xgr>){
		chomp();
		if ($_ =~ /^$RealPerl /){
			$VS->verbose(sprintf($bs, ++$bc));
			$VB->verbose($_);
			$VB->hline()
		}elsif(/^s/){ # stdout close error -1
                    # do nothing - this is a bug with the latest samtools version
                }else{
			$VB->verbose($_);
                        $VS->exit("bam2cns unexpectedly returned");
		}
	}

	$VS->verbose("Merging corrected output");
	my $fq_file = task_file_name(".fq");
	my $fq_glob = task_file_name(".[0-9]*.fq");
	my $fa_file = task_file_name(".masked.fa");

	my $tr_file = task_file_name(".debug.trace");
	my $tr_glob = task_file_name(".[0-9]*.debug.trace");
	my $fi_file = task_file_name(suffix => ".ignored.tsv", task => '');
	my $fi_glob = task_file_name(".[0-9]*.ignored.tsv");
	my $fc_file = task_file_name(".chim.tsv");
	my $fc_glob = task_file_name(".[0-9]*.chim.tsv");
	my $db_file = task_file_name(".debug.bam");
	my $db_glob = task_file_name(".[0-9]*.debug.bam");

	my @fq_glob = sort byfile glob $fq_glob;
	my @tr_glob = sort byfile glob $tr_glob;
	my @fi_glob = sort byfile glob $fi_glob;
	my @fc_glob = sort byfile glob $fc_glob;
        my @db_glob = sort byfile glob $db_glob;
#	my $fq_glob_sorted = join(" ", @fq_glob);
#	my $fa_glob_sorted = join(" ", @fa_glob);
#	my $fi_glob_sorted = join(" ", @fi_glob);
#	my $fc_glob_sorted = join(" ", @fc_glob);

	# create offset idx for reference
	my @ref_idxs = (0);
	my $offset = 0;
	# get fq indexes
	foreach(@fq_glob){
		$offset+= -s $_;
		push @ref_idxs, $offset;
	}

	# remove last one, its just the eof
	pop(@ref_idxs);

	qx(>$fq_file); # create empty file, just to be safe
	qx(>$tr_file) if @tr_glob > 0;
	# $fi_file gets appended over iters
	qx(echo -e "#id\tfrom\tto\tscore" > $fc_file); # create file with header

        for (my $i=0;$i<@fq_glob;$i+=500){
	    my $f = 0+$i;
	    my $t = 499+$i > $#fq_glob ? $#fq_glob : 499+$i;

	    system("cat ".join(" ", @fq_glob[$f..$t])." >>$fq_file") && die $!;
	    if(@tr_glob > 0){system("cat ".join(" ", @tr_glob[$f..$t])." >>$tr_file") && die $!};
	    system("cat ".join(" ", @fi_glob[$f..$t])." >>$fi_file") && die $!;
	    system("cat ".join(" ", @fc_glob[$f..$t])." >>$fc_file") && die $!;
	}

        if ( @db_glob ){
            system(cfg('samtools-path')."samtools merge $db_file @db_glob");
        }

	unlink @fq_glob unless $opt_keep > 1;
	unlink @tr_glob unless $opt_keep > 1;
	unlink @fi_glob unless $opt_keep > 1;
	unlink @fc_glob unless $opt_keep > 1;
	unlink @db_glob unless $opt_keep > 1;

        # Masking
        my @hcr_mask = split(",", cfg('hcr-mask', $TASK));
        $hcr_mask[2] = int(($hcr_mask[2] * $min_sr_length  / 100 ) +.5);
        $hcr_mask[3] = int(($hcr_mask[3] * $min_sr_length  / 100 ) +.5);
        my $hcr_mask = join(",", @hcr_mask );
        my $cmd = "$RealPerl/SeqFilter $fq_file --line-width 80 --quiet --out $fa_file --phred-offset 33 --phred-mask $hcr_mask --fasta --base-content N --tsv -";

        $VB->hline;
        $VB->verbose($cmd);
        my $re = qx($cmd);
        my ($bpt, $bpN) = (split(/\s/, $re))[1,6];
        $VB->hline;

        $V->exit("SeqFilter failed to mask $fq_file: $?\n") if $?;

        my $bpN_frac = $bpN/$bpt;
        $VB->nline;
        $VS->verbose(sprintf "Masked : %0.1f%%", $bpN/$bpt*100);

	return wantarray ? (\@ref_idxs, $bpN_frac) : \@ref_idxs; # wantarray guarantees backward compatibility
}

=head2 file_name

Create a file name depending on current $TC and $opt_prefix

  $TC = 1;
  $opt_prefix = "/foo";
  task_file_name(".suf"); # $TASKS[$TC]
    # "/foo_shrimp-iter-1.suf"
  task_file_name(".suf", prefix => "/foo/bar", task => 'custom');
    # "/foo_custom/bar_custom.suf"

=cut


sub task_file_name{
	my $p = {
		root => $opt_prefix,
		task => $TASKS[$TC || 0],
		prefix => $opt_prefix,
		suffix => (@_%2 ? shift : ''),
		@_
	};

	my $tfn = sprintf('%1$s/%2$s/%3$s%4$s', $p->{root}, $p->{task}, $p->{prefix}, $p->{suffix});
	$tfn =~ tr{/}{}s;
	return $tfn;
}


=head2 chunk_index

=cut

sub chunk_index{
    my $file = shift;
    my $fp;
    $fp = Fasta::Parser->new(file => $file)->check_format();
    $fp = Fastq::Parser->new(file => $file)->check_format() unless $fp;
    $fp || $VS->exit("Unknown format in file `$file`");


    # write sorted/indexed fq/fa lr file for mapping/sam2cns
    my @lr_idxs = (0);
    my $lr_c = 1;
    while($fp->next_seq){
        my $pos = $fp->append_tell();
        push @lr_idxs, $pos unless $lr_c % cfg('chunk-size');
        $lr_c++;
    }
    return \@lr_idxs;
}

=head2 create_custom_cfg

=cut

sub copy_custom_cfg{
	my ($cfg_core_file, $cfg_custom_file) = @_;
	open(COR, $cfg_core_file) or $VS->exit($!);
	open(CUS,'>',$cfg_custom_file) or $VS->exit("Couldn't create config file `$cfg_custom_file`");

	while(<COR>){
		if(/^#/){
			next unless /^##/;
			print CUS $_;
		}else{
			if(/^\s*$/){
				print CUS $_;
			}else{
				print CUS '#',$_;
			}
		}
	}

	close COR;
	close CUS;
}


=head2 chim_filter

Run ChimeraToSeqFilter on raw chimera output

=cut

sub chim_filter{

	my %params = (cfg('chimera-filter'), @_);
	my $params = param_join(\%params);

	my $cmd_chim_fil = "$RealPerl/ChimeraToSeqFilter.pl $params";

	$V->nline;
	$VS->verbose("Filtering chimera annotations");
	$VB->hline;
	$VB->verbose($cmd_chim_fil);
	qx($cmd_chim_fil);
	$VB->hline;

}


=head2 seq_chunker

Run SeqChunker. NO_EXEC as first param to only get command.

=cut


sub seq_chunker{
	my $no_exec;
	if($_[0] eq 'NO_EXEC'){
		shift @_;
		$no_exec++;
	}
	my @files;
	while($_[0] && $_[0] !~ /^-/){
		push @files, shift @_;
	}

	my %params = @_;
	my $params = param_join(\%params);
	my $files = join(" ", @files);
	my $cmd = "$RealBin/SeqChunker $params $files";

	return $cmd if $no_exec;

	$VB->hline;
	$VB->verbose($cmd);
	qx($cmd);
	$VB->hline;
}

=head2 seq_filter

Run SeqFilter on raw output

=cut


sub seq_filter{
	my %params = @_;
	my $params = param_join(\%params);

	my $cmd = "$RealPerl/SeqFilter $params";

	$VB->hline;
	$VB->verbose($cmd);
	qx($cmd);
	$VB->hline;
}

=head2 seq_and_siamaera_filter

Run seqfilter and siamaera on trimmed output

=cut


sub seq_and_siamaera_filter{
	my %seq_params = @{$_[0]};
	my $seq_params = param_join(\%seq_params);

	my %siam_params = @{$_[1]};
	my $siam_params = param_join(\%siam_params);

	my $cmd = "$RealPerl/SeqFilter $seq_params --out - | $RealPerl/siamaera".(cfg('blast-path') ? " --blast-path ".cfg('blast-path') : "")." $siam_params";

	$VB->hline;
	$VB->verbose($cmd);
	qx($cmd);
	$VB->hline;
}


=head2 byfile

Sort function for "natural" filesorting, descending.

=cut

sub byfile {
  my @a = split /(\d+)/, $a;
  my @b = split /(\d+)/, $b;
  my $M = @a > @b ? @a : @b;
  my $res = 0;
  for (my $i = 0; $i < $M; $i++) {
    return -1 if ! defined $a[$i];
    return 1 if  ! defined $b[$i];
    if ($a[$i] =~ /\d/) {
      $res = $a[$i] <=> $b[$i];
    } else {
      $res = $a[$i] cmp $b[$i];
    }
    last if $res;
  }
  $res;
}

=head2 is_empty_dir

Check whether a folder contains any files.

=cut

sub is_empty_dir {
    my $dirname = shift;
    opendir(my $dh, $dirname) or die "Not a directory";
    return scalar(grep { $_ ne "." && $_ ne ".." } readdir($dh)) == 0;
}


=head2 param_join (HASHREF, JOIN=STRING)

Joins a HASHREF to a parameter string with JOIN [" "], ignoring keys with
 undef values and creating flag only values for ''.

  param_join(HASHREF); # join with space
  param_join(HASHREF, join => "\n") # join with newline

=cut

sub param_join{
	my %params = %{shift @_};
	my $p = {
		'join' => " ",
		@_
	};

	# params
	my @params;
	my $params;
	foreach my $k (sort keys %params){
		my $v = $params{$k};
		# flag only is '', NOT '0' !!!
		next unless defined ($v);
		push @params, ($v ne '') ? ($k, $v) : $k;
	}
	$params .= join($p->{'join'}, @params);
	return $params;
}


=head2 cfg

Return parameter settings from %cfg w/r/t given task and global options

  $cfg{<PARAM>} = {
	DEF => 12, # global default
	<TASK1> => 8, # task specific settings, overuling global
	<TASK2> => 9, # task specific settings, overuling global
	<TASK2> => 0, # task specific settings, overuling global
  }

  $param = cfg(PARAM);        # 12
  $param = cfg(UNKNOWN_PARAM) # undef
  # by TASK_ID
  $param = cfg(PARAM,TASK1);  # 8
  $param = cfg(PARAM,TASK3)   # 12 (fall back to global)
  # by TASK_COUNT
  $param = cfg(PARAM, 1)      # 8 (first task in @TASK)
  $param = cfg(PARAM, -1)     # 0 (last task in @TASK)

=cut


sub cfg{
	my ($k, $t) = @_;

        unless (exists $cfg{$k}){
            $k =~ s/-\d+$//;
            return undef unless exists $cfg{$k};
        }

	return $cfg{$k} unless ref $cfg{$k};

	if(ref $cfg{$k} eq "ARRAY"){
		return wantarray ?	@{$cfg{$k}} : $cfg{$k};
	}

	if(! exists $cfg{$k}{DEF}){
		return wantarray ?	%{$cfg{$k}} : $cfg{$k};
	}

	my %p = %{$cfg{$k}};
	return undef unless %p;

	my $v = exists $p{DEF} ? $p{DEF} : undef;

	if(defined $t){
		if($t =~ /[^-0-9]/){ # task by id
                    if(exists $p{$t}){
                        $v = $p{$t}
                    }elsif($t =~ s/-\d+$//){ # task-id w/o counter bwa-mr[-1/-2/-3...]
                        $v = $p{$t} if exists $p{$t};
                    }
		}else{ # task by idx
                    $v = $p{$TASKS[$t]} if exists $p{$TASKS[$t]};
		}
	}
	return $v;
}

sub mask_shortcut_frac{
    my $mask_shortcut_frac = cfg('mask-shortcut-frac');
    return if (! $mask_shortcut_frac || $TC >= @TASKS-2); # no need to check in second to last task
    my ($masked_frac, $masked_fracs) = @_;
    my $masked_gain = cfg('mask-min-gain-frac');
    my $masked_prev = @$masked_fracs ? ${$masked_fracs}[-1] : -$masked_gain ;

    if($masked_frac > $mask_shortcut_frac){
        $VS->verbose("Masked > ". $mask_shortcut_frac*100 ."% total - skipping all but last iteration");
        $V->nline;
        splice(@TASKS, $TC+1, $#TASKS-$TC-1);
    }elsif($masked_prev && ($masked_frac - $masked_gain) < $masked_prev ){
        $VS->verbose("Masked < ". $masked_gain*100 ."% new - skipping all but last iteration");
        $V->nline;
        splice(@TASKS, $TC+1, $#TASKS-$TC-1);
    }else{
        $VS->verbose("Masked < ". $mask_shortcut_frac*100 ."% total / > ". $masked_gain*100 ."% new - continuing");
        $V->nline;
    }

    push @$masked_fracs, $masked_frac;
}


sub check_binary{
    my($bin, $ver) = (@_);
    my $fbin = $bin;
    unless(-e $fbin && -x $fbin){
      if($fbin = which($bin)){
        $VS->exit("Binary '$fbin' not executable") unless -e $fbin && -x $fbin;
      }else{
        $VS->exit("Binary '$bin' neither in PATH nor executable");
      }
    }

    $bin = basename($fbin);

    my $v;
    if($ver){
       $VS->exit("ARRAY ref required") unless ref $ver eq "ARRAY";

       my $vs = qx($fbin $ver->[0]);
       if($? or ! $vs){
           $VS->exit("Couldn't determine version of $bin, at least $ver->[1] required");
       }

       ($v) = $vs =~ /([0-9\.]+)/m;

       if(version->declare($v) < version->declare($ver->[1])){
           $VS->exit("Version $v of '$bin' < $ver->[1]");
       }

    }

    $VB->verbose(sprintf("  [ok] %-15s %s", $bin.($v ? "-$v" : ""), dirname($fbin)));

}


sub cov2seqchunker{
    my ($c, $tc) = @_;
    return 0 unless $opt_sampling;

    # don't sample if target coverage is more than 80% of given coverage
    return 0 if ($c*0.8) < $tc;

    my $chunks_per_step = int((cfg('sr-chunk-step') * ($tc/$c)) +.5);
    my $sc = {
              '--chunk-number' => cfg('sr-chunk-number'),
              '--chunk-step' => cfg('sr-chunk-step'),
              '--chunks-per-step' => $chunks_per_step,
              '--first-chunk' => $first_chunk, # an ugly global, 'cause its late and i'm tired
            };
    $first_chunk+= $chunks_per_step;
    $first_chunk-= cfg('sr-chunk-step') if $first_chunk > cfg('sr-chunk-step');
    return $sc;
}

##------------------------------------------------------------------------##

=head1 AUTHORS

=over

=item * Thomas Hackl, thomas.hackl@uni-wuerzburg.de
=item * Frank Foerster, frank.foerster@uni-wuerzburg.de

=back
